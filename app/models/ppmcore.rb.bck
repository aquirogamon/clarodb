class Ppmcore < ActiveRecord::Base

  serialize :ppmcores_array

  require 'rest-client'
  require 'json'
  require 'csv'

  def self.transport_stats(ip_address)
    fqdn = '&FQDN=Node%3D' + ip_address
    #base_url = "https://aquiroga:Cl4r0peru51@172.19.212.8:4440/ppm/rest/reports/Transport+Statistics/Interface/Interface+Bit+Rates?outputType=jsonv2&durationSelect=lastDay&intervalTypeKey=FIVE_MINUTE&maxPageSize=200000" + fqdn
    base_url = "https://aquiroga:Cl4r0peru51@172.19.212.8:4440/ppm/rest/reports/Transport+Statistics/Interface/Interface+Bit+Rates?outputType=jsonv2&durationSelect=last3Days&intervalTypeKey=FIVE_MINUTE&maxPageSize=200000" + fqdn
    begin
      data = RestClient::Request.execute(:url => base_url , :method => :get, :verify_ssl => false)
    rescue RestClient::ExceptionWithResponse => err
      err.response
    end
    data_parsed = JSON.load(data)
  end

  def self.devint(interfaces_file)
    CSV.read(Rails.root + "public/#{interfaces_file}.csv")[1..-1]
  end


    interfaces_file = 'core'
    #interfaces_file = 'preagg'
    #interfaces_file = 'acceso_cisco'
    @table = Hash.new { |hash, key| hash[key] = [] }
    @table_total = Array.new []
    @not_found = Array.new []

    devices = Array.new []
    extra_data = Hash.new { |hash,key| hash[key] = [] }
    interfaces = Hash.new { |hash,key| hash[key] = [] }

    Ppminterfacecore.devint(interfaces_file).each { 
      |a,b,c,d,e,f,g| interfaces[a] << [d,e.to_f]
      unless devices.include? [a,c]
        devices << [a,c]      
      end
      keystring = g
      extra_data[keystring] = Hash[device_total: a.to_s, router: b.to_s, bw: e.to_f, servicio: f.to_s]
    }
    
   data = Hash.new { |hash, key| hash[key] = [] }

    devices.map do |device|
      data[device[0]] = Ppminterfacecore.transport_stats(device[1])
      data[device[0]].map do |item|
        interfaces[device[0]].map do |interface|
         if interface[0].include? item[3]
            hash1 = Hash[bps_tx: item[5].gsub(/,/, '').to_f, bps_rx: item[6].gsub(/,/, '').to_f, int: item[0]]
            keystring = (device[0].to_s + item[3].to_s).to_s
            @table[keystring] << hash1
         end
        end
      end
    end

    devices.each do |device|
      interfaces[device[0]].each do |interface|
        keystring = (device[0].to_s + interface[0].to_s).to_s
        if @table[keystring] != []
          maxtx = ((@table[keystring].sort { |a,b| a[:bps_tx] <=> b[:bps_tx] }.last[:bps_tx])/1000000000).round(2)
          maxrx = ((@table[keystring].sort { |a,b| a[:bps_rx] <=> b[:bps_rx] }.last[:bps_rx])/1000000000).round(2)
          int = @table[keystring].first[:int]
          if int.include? "Bundle-Ether"
            pos = 0
            positions = []
            while (pos = int.index("-", pos + 1))
              positions << pos
            end
            #int = int[positions[-2]+1..-1]
          else
            #int = int[int.rindex('-')+1..-1]
          end
          hash2 = Hash[node: device[0],
            bw: extra_data[keystring][:bw],
            iru: extra_data[keystring][:iru], 
            tier1: extra_data[keystring][:tier1],
            link: extra_data[keystring][:link],
            remote_site: extra_data[keystring][:remote_site],
            route: extra_data[keystring][:route],
            local_site: extra_data[keystring][:local_site],
            activation_date: extra_data[keystring][:activation_date],
            comments: extra_data[keystring][:comments],
            #interface: int[int.rindex('-')+1..-1], 
            interface: int, 
            bps_tx: maxtx, bps_rx: maxrx,
            utilization_tx: ((maxtx/interface[1])*100.00).round(2),
            utilization_rx: ((maxrx/interface[1])*100.00).round(2) ]
          @table_total << hash2
        else
          @not_found << [device,interface]
        end
      end
    end

    puts "Devices not found: " + @not_found.to_s
    return @table_total

 end

end
